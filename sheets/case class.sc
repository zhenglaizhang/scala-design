// todo
//https://de.slideshare.net/debasishg/dependency-injection-in-scala-beyond-the-cake-pattern

// For a case class the Scala compiler does the following for you:
//    - Creates a class and its companion object.
//    - Implements the apply method that you can use as a factory. This lets you create instances of the class
//    without the new keyword
//    - Prefixes all arguments, in the parameter list, with val. This means the class is immutable, hence you get the
//    accessors but no mutators
//    - Adds natural implementations of hashCode, equals and toString. Since == in Scala always delegates to equals,
//    this means that case class instances are always compared structurally
//    - Generates a copy method to your class to create other instances starting from another one and keeping some
//    arguments the same.
//    - Probably, most importantly, since the compiler implements the unapply method, a case class supports pattern
//    matching. This is especially important when you define an Algebraic Data Type (ADT).
//    - Apart from being used in pattern matching the unapply method lets you deconstruct a case class to extract
//    it’s fields, both during pattern matching and as a simple expression to extract some of its fields
//    - What if you need a function that, given your case class arguments as parameters, creates an instance of the
//    class? Here’s how you can do it by partially applying apply
//    - What if you want your function, from the previous point, to be curried? Enters the curried method:
//    - What about obtaining a function that accepts a tuple whose arity is equal to the number of the case class
//    arguments, and produces an instance of the class? Well, there’s the tupled method
//    - You could also need a function that, given an instance of your class as input, produces an Option[TupleN[A1, A2,
//      ..., AN]] as output, where N is the number of the case class arguments and A1, A2, ..., AN are their types.
//    - The curried and tupled methods are inherited from AbstractFunctionN which is extended by the autogenerated
//    companion object. N is the number of the case class formal parameters. Note that, of course, if N = 1 you won’t
//    get curried and tupled because they wouldn’t make sense for just one parameter!
//    - Defining a case class using the curried form: case class A(text: String)(age: Int)
//    - Mark case class apply and copy as private to control the construction
//    - inherits Product (productArity/productPrefix/productIterator/ProductElement
//    - Product extends Equals so every case class also inherits the canEqual method, unless you decide to implement
//    your own version of equals in which case you need to take into account canEqual
sealed trait Maybe[+A]

case class Value[A](value: A) extends Maybe[A]

case object NoValue extends Maybe[Nothing]

val v: Maybe[Int] = Value(12)
val v_1: Maybe[Int] = NoValue

def logValue[A](value: Maybe[A]): Unit =
  value match {
    case Value(v) => println(s"Value: $v")
    case NoValue => println("no value")
  }

logValue(v)
logValue(v_1)

case class Person(firstname: String, lastname: String, age: Int)

val p = Person("f", "l", 12)
val Person(firstname, _, _) = p
println(firstname)

val personCreator: (String, String, Int) => Person = Person.apply _
personCreator("f1", "l1", 12)

val curriedPerson: String => String => Int => Person = Person.curried
val zhenglaiBuilder: String => Int => Person = curriedPerson("zhenglai")
val brother = zhenglaiBuilder("Zhang")(30)

val tupledPerson: ((String, String, Int)) => Person = Person.tupled
val meAsTuple: (String, String, Int) = ("zhengali", "zhang", 20)
val p2 = tupledPerson(meAsTuple)

val toOptionOfTuple: Person => Option[(String, String, Int)] = Person.unapply _
val x: Option[(String, String, Int)] = toOptionOfTuple(p)

// The formal parameters in the first parameter section of a case class (just text in this case) are called elements;
// they are treated specially. All the goodies you get when you define a case class (accessors, pattern matching
// support, copy method, …) only apply to the first section.
case class Keyword(text: String)(source: String, foo: Int)

val k1 = Keyword("restaurant")("storage", 1)
k1.text

//k1.source
//k.foo

// You can solve the accessor problem by prefixing the parameters with val.
case class Keyword(text: String)(val source: String, val foo: Int)

// Anyway you still won’t get all the other case class features. For instance, you cannot use the copy method by
// specifying only the source parameter
//val k2 = k1.copy()(source = "web")
val k3 = k1.copy()(source = "web", foo = 1)

// Finally, the companion object of a case class defined in such a way won’t extend AbstractFunctionN, so the tupled
// and curried methods are not available.

// why??
//  Apparently there are cases when it could be a reasonable choice. For example suppose that, for your business
//  model, two instances of Keyword are to be considered equal iff they have the same text field

val k1 = Keyword("trait")("storage", 1)
val k2 = Keyword("trait")("cosmos", 3)
k1 == k2 // true

// That’s because also the equals implementation, you get for free for case classes, only applies to the first
// parameter section, so only to text in this case

// Defining a case class with a private constructor
// Sometimes you’ll want to control the construction of a case class so that you can perform a validation of the
// inputs at contruction-time
case class Natural private(value: Int) {
  private def copy(): Unit = ()
}

object Natural {
  //  def apply(value: Int): Option[Natural] =
  //    if (value < 0) None else Some(new Natural(value))

  // smart ctor
  // The name fromInt communicates more clearly the concept of a possible failure while one expects that apply is a
  // non-effectful method
  def fromInt(n: Int): Option[Natural] = if (n >= 0) Some(Natural(n)) else None
}

val x = Natural.fromInt(122)
Natural.fromInt(-1)
// A hole here, need mark copy as private
//x.map(_.copy(value = -2)) // Some(-2)

// another hole here
Natural(-1)

x.foreach {
  case Natural(v) => println(s"Natural number: $v")
}

// much better solution
// https://gist.github.com/tpolecat/a5cb0dc9adeacc93f846835ed21c92d2
// https://gist.github.com/longliveenduro/62638ec95a6fd0c6576bdb77ca88cd6b
sealed abstract case class Nat(toInt: Int)

object Nat {
  def fromInt(n: Int): Option[Nat] = if (n >= 0) Some(new Nat(n) {}) else None
}

val on = Nat.fromInt(-1)
val on = Nat.fromInt(1)
on.collect {
  case Nat(n) => n
}
val n = on.get
Nat.unapply(n)

Nat.fromInt(3) == Nat.fromInt(3)
//n.copy(-1)

p.productArity // 3
val fname: Any = p.productElement(0)
val age: Any = p.productElement(2)
p.productIterator
val classname = p.productPrefix

//
// Case Classes w/ Smart Ctors
//

// Case classes with > 22 parameters are now allowed”.
// The 22 limit lives on in functions and tuples.

// So it’s great that the restriction was relaxed in Scala 2.11.
// However, while the 22 limit was lifted for some common cases, it was not universally removed.
// https://underscore.io/blog/posts/2016/10/11/twenty-two.html
case class Large(
                  a: Int,
                  b: Int,
                  c: Int,
                  d: Int,
                  e: Int,
                  f: Int,
                  g: Int,
                  h: Int,
                  i: Int,
                  j: Int,
                  k: Int,
                  l: Int,
                  m: Int,
                  n: Int,
                  o: Int,
                  p: Int,
                  q: Int,
                  r: Int,
                  s: Int,
                  t: Int,
                  u: Int,
                  v: Int,
                  w: Int
                )

case class Small(a: Int, b: Int)

// We have field accessors, a constructor, equality, hash code, copy, and product methods, but also these two methods:
//  - unapply - from Product2 (via Tuple2); and
//  - tupled - from Function2.

Small.unapply _
// val res0: Small => Option[(Int, Int)] = <function>
// Small.unapply is the extractor method.
// If we partially apply using _ we end up with a function value

Small.tupled
// val res1: ((Int, Int)) => Small = scala.Function2<function>

val large = Large(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
  19, 20, 21, 22, 23)
large.w
val w = large match {
  case Large(
  a,
  b,
  c,
  d,
  e,
  f,
  g,
  h,
  i,
  j,
  k,
  l,
  m,
  n,
  o,
  p,
  q,
  r,
  s,
  t,
  u,
  v,
  w
  ) =>
    s"w is $w"
}
// But you won’t find Large.tupled or Large.unapply.
// Those methods don’t exist on Large.

// The fix(https://github.com/scala/scala/pull/2305) introduced in Scala 2.11 removed the limitation for the above
// common scenarios: constructing case classes,
// field access (including copying), and pattern matching (baring edge cases).
//
//It did this by omitting unapply and tupled for case classes above 22 fields. In other words, the limit to
// Function22 and Tuple22 still exists.

//(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
//  23)
// tuples may not have more than 22 elements, but 23 given

// workaround the limit

//
// use nested tuples
//
(
  (1, 2, 3, 4, 5, 6, 7),
  (8, 9, 10, 11, 12, 13, 14, 15),
  (16, 17, 18, 19, 20),
  (21, 22, 23)
)

//
// use heterogeneous lists (HLists), where there’s no 22 limit.
//

// - How the 22 limit on case classes was removed in Scala 2.11 for some uses, but not all.
// - Where the limit still applies, on FunctionN and TupleN.
// - An example of how the limit manifests itself in libraries such as Slick.
// - Workarounds using nested tuples and HLists.
